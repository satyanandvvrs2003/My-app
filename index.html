<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Seamless Multi-Track Looper</title>
<style>
  body {
    background:#e0e5ec; font-family:sans-serif; margin:0; display:flex; justify-content:center; align-items:flex-start; padding:20px; min-height:100vh;
  }
  .container {
    width: 100%; max-width: 430px; padding:20px; background:#e0e5ec; border-radius:25px;
    box-shadow:8px 8px 20px #babecc, -8px -8px 20px #fff; display:flex; flex-direction:column; align-items:center;
  }
  h2 {
    margin-bottom:20px; font-size:1.5em; color:#333; text-align:center;
  }
  button {
    margin:8px 5px; padding:12px 14px; border:none; border-radius:20px;
    box-shadow:4px 4px 12px #babecc, -4px -4px 12px #fff; font-size:1em; cursor:pointer; background:#e0e5ec;
    transition:all 0.2s; flex-shrink:0;
  }
  button:active {
    box-shadow: inset 4px 4px 12px #babecc, inset -4px -4px 12px #fff;
  }
  #tracks {
    width:100%; margin-top:20px; display:flex; flex-direction:column; gap:18px;
  }
  .track {
    background:#f1f2f6; border-radius:20px; padding:15px 20px 20px 20px;
    box-shadow:4px 4px 12px #babecc, -4px -4px 12px #fff; display:flex; flex-direction: column; gap: 10px;
  }
  .track-header {
    font-weight:600; color:#444; font-size:1.1em;
  }
  .controls {
    display:flex; flex-wrap: wrap; justify-content:center; gap:10px;
  }
  .timer {
    font-family: monospace; font-size:14px; color:#555; margin-left:10px;
    min-width:60px; text-align:center;
  }
  .volume-control {
    display:flex; align-items:center; gap:6px; width:100%; max-width:150px; margin-top:6px;
  }
  input[type="range"] {
    flex-grow:1;
  }
  @media(max-width:480px){
    .container { max-width: 100%; padding: 15px; }
    button { padding: 10px; font-size: 14px; }
  }
</style>
</head>
<body>
<div class="container">
<h2>üéß Seamless Multi-Track Looper</h2>
<div id="tracks"></div>
<button id="addTrack">+ Add Track</button>
<button id="exportAudio">üíæ Export All Tracks</button>
<p><em>Recording stops on play and loop starts immediately, multi-track volume control and delete options included.</em></p>
</div>
<script>
(async () => {
  let trackCount = 0;
  let mediaRecorders = [];
  let mediaStreams = [];
  let audioBlobs = [];
  let loopAudios = [];
  let audioURLs = [];
  let isRecording = [];
  let timers = [];
  let timerIntervals = [];
  let volumes = [];

  const STORAGE_KEY = 'multiTrackLooperData';
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();

  async function resumeAudio() {
    if(audioContext.state === 'suspended') {
      await audioContext.resume();
    }
  }

  function formatTime(sec) {
    const m = Math.floor(sec / 60).toString().padStart(2, '0');
    const s = (sec % 60).toString().padStart(2, '0');
    return `${m}:${s}`;
  }

  function startTimer(i) {
    let sec = 0;
    timers[i].textContent = formatTime(sec);
    timerIntervals[i] = setInterval(() => {
      sec++;
      timers[i].textContent = formatTime(sec);
    }, 1000);
  }

  function resetTimer(i) {
    clearInterval(timerIntervals[i]);
    timers[i].textContent = '00:00';
  }

  function clearAudioURL(i) {
    if(audioURLs[i]) {
      URL.revokeObjectURL(audioURLs[i]);
      audioURLs[i] = null;
    }
  }

  async function blobToBase64(blob) {
    if(!blob) return null;
    return new Promise(resolve => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.readAsDataURL(blob);
    });
  }

  async function base64ToBlob(base64) {
    if(!base64) return null;
    const res = await fetch(base64);
    return await res.blob();
  }

  async function saveAll() {
    const base64List = await Promise.all(audioBlobs.map(blobToBase64));
    localStorage.setItem(STORAGE_KEY, JSON.stringify(base64List));
  }

  async function loadAll() {
    const storedData = localStorage.getItem(STORAGE_KEY);
    if(!storedData) return;
    const base64List = JSON.parse(storedData);
    for(let i=0; i<base64List.length; i++) {
      if(base64List[i]){
        audioBlobs[i] = await base64ToBlob(base64List[i]);
        createTrack(i, true);
      }
    }
  }

  function createTrack(idx=null, hydrated=false) {
    if(idx===null) {
      idx = trackCount++;
    } else if(idx >= trackCount) {
      trackCount = idx +1;
    }

    const container = document.getElementById('tracks');
    const trackDiv = document.createElement('div');
    trackDiv.className = 'track';
    trackDiv.id = `track-${idx}`;
    trackDiv.innerHTML = `
      <div class="track-header">Track ${idx+1}</div>
      <div class="timer" id="timer${idx}">00:00</div>
      <div class="controls">
        <button id="record${idx}">üéôÔ∏è Record</button>
        <button id="play${idx}">üîÑ Play Loop</button>
        <button id="stop${idx}">‚èπÔ∏è Stop</button>
        <button id="delRec${idx}">üóëÔ∏è Delete Recording</button>
        <button id="delTrack${idx}">‚ùå Delete Track</button>
      </div>
      <div class="volume-control">
        <label for="volume${idx}">Volume</label>
        <input type="range" id="volume${idx}" min="0" max="1" step="0.01" value="1" />
      </div>
    `;
    container.appendChild(trackDiv);

    timers[idx] = document.getElementById(`timer${idx}`);
    volumes[idx] = document.getElementById(`volume${idx}`);

    isRecording[idx] = false;

    document.getElementById(`record${idx}`).onclick = async () => {
      await resumeAudio();
      if(isRecording[idx]){
        mediaRecorders[idx].stop();
        mediaStreams[idx].getTracks().forEach(t => t.stop());
        resetTimer(idx);
        isRecording[idx] = false;
        document.getElementById(`record${idx}`).textContent = 'üéôÔ∏è Record';
      } else {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({audio:true});
          mediaStreams[idx] = stream;
          const rec = new MediaRecorder(stream);
          mediaRecorders[idx] = rec;
          let chunks = [];
          rec.ondataavailable = e => chunks.push(e.data);
          rec.onstop = async () => {
            audioBlobs[idx] = new Blob(chunks, {type:'audio/webm'});
            chunks = [];
            clearAudioURL(idx);
            audioURLs[idx] = URL.createObjectURL(audioBlobs[idx]);
            await saveAll();
          };
          rec.start();
          isRecording[idx] = true;
          startTimer(idx);
          document.getElementById(`record${idx}`).textContent = '‚èπÔ∏è Stop Recording';
        } catch (e) {
          alert('Mic permission chahiye!');
          console.error(e);
        }
      }
    };

    document.getElementById(`play${idx}`).onclick = async () => {
      if(!audioBlobs[idx]){
        alert('Pehle record karo!');
        return;
      }
      if(isRecording[idx]){
        // Recording chal rahi hai to pehle recording stop karo and wait for onstop event
        const rec = mediaRecorders[idx];
        const stream = mediaStreams[idx];
        if(rec && stream){
          rec.stop();
          stream.getTracks().forEach(t => t.stop());
          resetTimer(idx);
          isRecording[idx] = false;
          document.getElementById(`record${idx}`).textContent = 'üéôÔ∏è Record';
          await new Promise(resolve => rec.onstop = resolve);
        }
      }
      if(!audioURLs[idx]){
        clearAudioURL(idx);
        audioURLs[idx] = URL.createObjectURL(audioBlobs[idx]);
      }
      if(loopAudios[idx] && !loopAudios[idx].paused){
        loopAudios[idx].pause();
        document.getElementById(`play${idx}`).textContent = 'üîÑ Play Loop';
        return;
      }
      const audio = new Audio(audioURLs[idx]);
      audio.loop = true;
      audio.volume = volumes[idx].value;
      audio.play();
      loopAudios[idx] = audio;
      document.getElementById(`play${idx}`).textContent = '‚èπÔ∏è Pause Loop';
    };

    document.getElementById(`stop${idx}`).onclick = () => {
      if(isRecording[idx]){
        mediaRecorders[idx].stop();
        mediaStreams[idx].getTracks().forEach(t => t.stop());
        resetTimer(idx);
        isRecording[idx] = false;
        document.getElementById(`record${idx}`).textContent = 'üéôÔ∏è Record';
      }
      if(loopAudios[idx] && !loopAudios[idx].paused){
        loopAudios[idx].pause();
        document.getElementById(`play${idx}`).textContent = 'üîÑ Play Loop';
      }
    };

    // Delete Recording
    document.getElementById(`delRec${idx}`).onclick = () => {
      if(isRecording[idx]){
        alert('Recording chal rahi hai, pehle stop karo!');
        return;
      }
      if(loopAudios[idx] && !loopAudios[idx].paused){
        loopAudios[idx].pause();
        document.getElementById(`play${idx}`).textContent = 'üîÑ Play Loop';
      }
      audioBlobs[idx] = null;
      clearAudioURL(idx);
      saveAll();
      alert(`Track ${idx+1} ka recording delete ho gaya.`);
    };

    // Delete Track
    document.getElementById(`delTrack${idx}`).onclick = () => {
      if(isRecording[idx]){
        alert('Recording chal rahi hai, pehle stop karo!');
        return;
      }
      if(loopAudios[idx] && !loopAudios[idx].paused){
        loopAudios[idx].pause();
      }
      audioBlobs[idx] = null;
      clearAudioURL(idx);
      mediaRecorders[idx] = null;
      mediaStreams[idx] = null;
      resetTimer(idx);
      document.getElementById(`track-${idx}`).remove();
      saveAll();
    };

    volumes[idx].oninput = () => {
      if(loopAudios[idx]){
        loopAudios[idx].volume = volumes[idx].value;
      }
    }
  }

  document.getElementById('addTrack').onclick = () => createTrack();

  document.getElementById('exportAudio').onclick = () => {
    if(audioBlobs.every(b => !b)){
      alert('Koi recording nahi!');
      return;
    }
    audioBlobs.forEach((b,i) => {
      if(b){
        const url = URL.createObjectURL(b);
        const a = document.createElement('a');
        a.href = url;
        a.download = `Track_${i+1}.webm`;
        a.click();
      }
    });
  };

  await loadAll();
  if(document.getElementById('tracks').children.length === 0) createTrack();
})();
</script>
</body>
</html>
